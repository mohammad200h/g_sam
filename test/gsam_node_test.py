import os
import sys
import json
import numpy as np

from skimage.metrics import structural_similarity as ssim

from rclpy.node import Node

import pytest
import time

import rclpy
from rclpy.executors import SingleThreadedExecutor

from foundation_pose_interfaces.srv import Registration
from std_msgs.msg import String


from cv_bridge import CvBridge

folder_path = os.path.dirname(os.path.abspath(__file__))

TEST_DATA_PATH=folder_path + '/test_data/mustred0'

def load_mask():
  path = TEST_DATA_PATH+"/registeration_npy/register_ob_mask.npy"
  return np.load(path)


def get_iou(expected,out):
  # Compute Intersection over Union (IoU)
  intersection = np.logical_and(expected, out)
  union = np.logical_or(expected, out)
  iou = np.sum(intersection) / np.sum(union)

  return iou

def get_ssim(expected,out):
  # Compute Structural Similarity Index (SSIM)
  ssim_score, _ = ssim(expected, out, full=True)

  return ssim_score



class GSAMClientNodeTest(Node):
  def __init__(self):
    super().__init__('GSAMClientNodeTest')

    self.flags = {
      "registration_callback_called":False
    }

    self.color = None
    self.depth = None
    self.mask  = None

     # try to register the object
    self.regeneration_client = self.create_client(Registration,
                                                  '/foundation_pose_regeneration')

    while not self.regeneration_client.wait_for_service(timeout_sec=1.0):
      self.get_logger().info('Waiting for foundation_pose_regeneration service...')
    self.send_registration_request()

  def send_registration_request(self):
     # Since there is no request part, we send an empty request
     self.request = Registration.Request()
     string_msg = String()
     string_msg.data = 'musturd'
     self.request.prompt = string_msg

     self.future = self.regeneration_client.call_async(self.request)
     self.future.add_done_callback(self.registration_callback)

  def registration_callback(self, future):
    try:
      response = future.result()

      print("\n")
      print(f"registration_callback::response::{response.mask.header.frame_id}")
      print(f"registration_callback::response::{response.color.header.frame_id}")
      print(f"registration_callback::response::{response.depth.header.frame_id}")
      print("\n")

      self.color = response.color
      self.depth = response.depth
      self.mask = response.mask

      self.flags["registration_callback_called"] = True

    except Exception as e:
      self.get_logger().error(f"Service call failed: {e}")

@pytest.fixture
def ros_client_setup():
  rclpy.init()

  test_node = GSAMClientNodeTest()
  executor = SingleThreadedExecutor()
  executor.add_node(test_node)
  yield test_node, executor
  test_node.destroy_node()
  rclpy.shutdown()


def test_registration(ros_client_setup):
  """
  Generated Mask Image should match the mask in database
  """
  test_node, executor = ros_client_setup

  # Wait for the publisher to initialize
  time.sleep(1)  # Adjust this value based on the expected setup time
  # Run the executor and check for messages
  try:
    for _ in range(1000):
      executor.spin_once(timeout_sec=1)
      if test_node.flags["registration_callback_called"]:

        assert test_node.color
        assert test_node.depth
        assert test_node.mask

        # make sure the mask generated by
        # gsam matches ground_truth mask
        expected_mask = load_mask()
        mask = CvBridge().imgmsg_to_cv2(test_node.mask,
                                        desired_encoding="mono8").astype(bool).astype(np.uint8)

        iou = get_iou(expected_mask,mask)
        ssim_score = get_ssim(expected_mask,mask)

        assert iou > 0.95
        assert ssim_score > 0.99

        return
    assert False
  finally:
    pass



# Note: Need to launch publisher in terminal. the test does not launch a publisher
# ros2 run fake_realsense fake_realsense # make sure first image is being published
# ros2 run g_sam g_sam

# to run test
# colcon test